----20190108作业----

双向链表--->Node可用struct，因为只有public的

> List构造函数，没有初始化，就对 _head 进行赋值，野指针
	必须先为_head开辟空间
	（9：58）
> 对于指针的操作，一定要先进行初始化（否则空指针，解引用...全都赋值...全都有问题）

	注：实现代码的时候，不要全写完了再测试
		最好是一个一个函数测试，写完一个，就测试一个{增量实现代码方式}
		否则全写完了，error，不容易知道问题出在哪
		（即，要实现：文件是可追溯的）

> size_t 无符号整型，可以保证数据>0（遍历，计数之类）
		（size_t默认是unsigned long，占8个字节）


> 切记进行初始化，构造函数的初始化表达式中对_pre和_next进行new Node()操作
> 构造函数内，还要把_head的next指针指向_tail，_tail的pre指针指向_head，从而把初始的两个节点连在一起，形成链表

> display()时，先要判断_size是否为0，即链表里是否有元素
	有的话，才能打印

> push_front()：在头部添加节点，只跟_head有关系
	先new Node(data)创建一个节点，
	然后就是：四个指针的调整赋值，以及_size++
	{本来应该判断指针为空，但是现在因为是new出来的，所以不必了} 10：28？？ 

> ~LinkList()：链表的析构函数中，要释放所有节点的空间
	先获取节点：当前要删除节点deleteNode = _head->next;
	循环判断：当链表中不为空时（有节点，即当前删除节点不为空）
		暂存deleteNode->next，然后释放当前删除节点，再把当前删除节点指向刚才的暂存节点

> insert(Node *, int value)：在某节点之前添加数据
	首先要判断这个节点是否存在，所以得先遍历查找，可先自定义一个Node * find(Node * p)方法
	10：38？？

> erase(Node *)：删除一个节点，首先也是要进行查找

{定义了几个私有方法，作为具体实现，上面的public方法作为对外接口，内部调用相应私有方法}

------> 头尾两个指针，很多余，可以首尾相接，变成一个循环双向链表，这样不再需要尾指针，
	11：45？？
{笔试题：双向链表、逆置双向链表}
{必须自己实现一下：逆置单链表！！！！}
《剑指offer》


----0110作业----
词典
> 可以用容器vector<> _dict
> 自己设一个struct，作为容器的元素
11：10


----->以后尽量用vector，而不用数组[]
		字符串尽量用string，而不用const char *
			两个后者都比较原始，很容易出错

> 建议一行一行读 getline(ifs, line)
> 要对word进行处理（处理的过程很繁琐，所以单独提取出来写一个函数）
	11：22
{对于一个函数的实现，代码不要超过50行}

> c语言已经有函数判断字母了，isalpha(char)


> insert()方法，当该词就在词典中时，词频加1
				当是一个新词的时候，把新词加进词典里


> store()方法：存储
	打开文件，进行输出（记得close()关闭流）

{实现的代码，最好是能够自解释的，即，一看就懂，不必中间还添加注释，只有函数头注释一下功能}

> {现在实现的词典，得到的结果比较乱，可以对结果进行一下排序}
{cppreference下的algorithm里提供了许多算法，sort就是其中之一}
	11：43？？

-----迭代器？？？
	11：46？？
{容器库，begin，end，相当于左闭右开的区间}
	～ 报错，sort默认比较的时候使用<符号进行比较的
			因此必须重载Record的<运算符

-----{想看执行时间，可以加上时间函数}
	---1970年1月1日是UNIX的诞生时间，所以作为元年？
	time_t beg = ::time(NULL);
	//...
	time_t end = ::time(NULL);
	开始和结束分别获取一下时间，相减（CPU的时间片以纳秒记）

{后面会学到map，速度比vector快的多}	O(logN)  -- O(N)
{还有"字典树" ==> trie树}	O(len(word))
{shell脚本 --> vector --> map --> 字典树}




----0111作业----
log4cpp封装

> 头文件别忘了预处理

> 数据成员只需要：Category，
	因为最终在调用warn的时候，PatternLayout等不会用到

> 声明的时候放在了命名空间namespace wd里
	实现的时候也必须放在命名空间namespace wd里

> 可以自定义优先级，用枚举，然后自定义setPriority方法
	14：56？？？

> 之所以静态数据成员的定义不能放在头文件里
	是因为很多地方都会引用这个头文件，即会出现"多次定义"
	所以说静态数据成员的定义才要放在 实现文件 .cc 里

> 为什么要自定义Priority，直接用log4cpp给的不行吗？
	因为希望调优先级的时候，不再调用log4cpp的库，也不再需要include <log4cpp/Priority.hh>头文件
	即：引入一个Mylogger.h头文件就够了，不应还需要引入log4cpp的东西

> 文件名、函数名、行号，用C语言内置宏
	__FILE__  __FUNCTION__  __LINE__
	c++中int to string的方法：std::to_string(int)
	15：30

> string to const char *：string.c_str()

> 但是发现，打出来的行号，函数名，不是test0()的
	而是打出了prefix的了
  也就是说，调用函数是不行的，要把prefix变成一个宏定义，而非函数
> 如果拼接的时候使用 "+"，会产生很多的中间变量，所以换用append()
> 对于宏而言，如果是有多行，要换行的时候，必须加"\"表示这些是在同一行
	15：39
> append完了以后，是一个string，记得str.c_str()转为const char *
{这个定义的宏应该放进.h里面去}

---->而我们最终想要的是调用 LogError 这类方法，实现功能
	所以再把这些方法定义成几个类似宏，
	16：03
---->当前功能是实现了，但是LogError()这些方法和printf()还是差距很大
	比如LogError("this is a error message! %s", pstr);这种就不行，没法使得 %s 可以代替
	不实现这种，就不算真正的日志系统，在项目里是没法用的，只能打印死信息


----------------------------------------------------

----0114----

普通函数重载：对于数据成员，如果是public的，就用这种方式
友元函数重载（本身又可以分为普通函数、成员函数）：
	> 友元普通函数：+ - * / 单目运算符， == != < >
	> 友元成员函数：
成员函数重载：当执行完毕后，对象本身的值发生了改变
	> +=
	> ++ -- =====> 前置++返回值是引用，后置++返回值是对象，（后置的参数列表之中，用一个int来作为与前置的区分标志位，本身无意义）
	> = 赋值运算符



--------
1、小括号：函数调用运算符
> int operator()(int x, int y){...}
	小括号就是函数调用运算符
	16：25
	{测试代码}

> 与平时的函数调用有什么不同？
	～重载了函数调用运算符的类，称为函数对象
	～函数的话，执行完了以后，就啥也不剩了，没有携带状态
		而函数对象，本身有数据成员，即作为"函数的状态"
		（例如记录函数被调用了几次，在函数中要想实现，就得定义一个局部静态变量）
		16：34？
		（但函数只能有一个，而函数对象，作为对象，可以创建无限个，每个都可以有自己的状态）
		（一般把携带了状态的函数对象，称为"闭包"）？？
		16：37？ ==> 闭包 ==> 匿名函数 ==> lambda表达式
	～

-------------

2、中括号：下标访问运算符

> 
16：52？

> const版本
16：57？

> 下标访问运算符，有两个参数：
	第一个操作数是对象本身，第二个参数可以是任意类型
	（string，vector等之所以能像使用数组一样[]去访问元素，就是因为他们重载了下标访问运算符）


补充：
{一般出现segement段错误，就是出现了空指针导致的，即野指针}

{
	所以可以养成习惯：
	
	~CharArray()
	{
		delete [] _data;
		_data = nullptr;//释放完，立即设为空指针
	}

}




3、对于new，delete运算符重载，还可以机上static关键字，加不加都一样

4、输入流，输出流运算符：>>  <<
	> 返回值是 std::ostream & ，是引用，不能是对象，因为流对象都不能复制（而返回值是对象，会调用复制构造函数）
	> 如果作为成员函数，第一个参数是this指针
		而输出流运算符要求左操作数为流对象，右操作数才是要输出的内容
			此时就产生了矛盾
		所以输出流运算符不能以成员函数进行重载
		--->所以只能使用友元函数了，因为还要用私有成员

	> {链式编程}   {切记：输出流运算符不是成员函数}

	> 输入流：
		想循环输入，结果没成功，流的状态出了问题？
		17：40？
		～要考虑健壮性

5、指针运算符，解引用运算符，后面只能只能要用到


-------------------------------------------------------------
tips：
1、快捷键：自动缩进格式调整：gg=G
（文件不用每次winscp之类的，可以直接拖进来）
2、win中的内容，复制，粘贴到vim里：shift+insert
3、c++文件，文件名用大写Link.cc


ubuntu输入法：
打开设置--->language--->提示安装，安装 ---> 再把简体中文安装
---> 下载fctix，安装fctix-pinyin
---> 选择fctix模式，不用ibus模式

{复试宝典解压密码：ququshinanshen}
