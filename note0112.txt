------0112------

类域、友元、运算符重载
hypot(x, b)：x和y的平法


一、
友元：
> 普通函数
> 成员函数

类的前向声明

对于普通函数，使用friend声明

对于成员函数，通过：
	类的

	{用引用，而不用指针，因为指针作为行惨，必须知道多大，得开辟空间}



> 友元类：
	friend Line; //干脆把整个类都设置尾朋友
	freind class Line;

> 友元关系是单向的（你是我的朋友，但我不是你的朋友）
> 而且不具备传递性（a是b的朋友，b是c的朋友）
> 不能被继承（你老爸的朋友，不一定都是你的朋友）

重载的函数，要想都友元，必须每个都声明friend
（只有声明了的那个，才能是朋友，没声明不是）



二、运算符重载
（目的就是为了让自定义类型的数据操作，和内置类型能一致）（如+，-，×，/）

> 经典举例：（复数 Complex.cc）
	--补：《重温微积分》
{写的时候就发现很麻烦，打印不能 cout << "c1=" << c1}
{而且居然不能 Complex c3 = c1 + c2，所以必须要进行运算符重载}

	//第一种：普通函数形式进行重载
	Complex operator+(const Complex & lhs, const Complex & rhs)
	{
		return ...
	}

	//不想要get()函数 {数据成员多了，十分冗余} ----> 友元11：06
	//即第二种形式：以友元函数进行重载

	//第三种方式：成员函数形式进行重载

	（为什么不用指针、引用，而是返回值用对象？因为+，-这类的，并没有改变a，b的值，所以我们这里也不去改变Complex对象的值）


	// a = b + c;
	～～～～对于+，-这种，第二种方式，最简洁，而且与内置类型的数据在操作形式上保持一致～～～～
	（其实首先他是一个普通函数，只不过在类内给他设置为友元了）
	（这样不用像普通函数那样，定义一堆get，）

	// a += b; //复合赋值运算符推荐以成员函数进行重载，返回值用 & 引用（因为对象本身已经发生变化）
	～～～～而对于+=这种，执行完后，a的值已经变了，就以成员函数的形式进行重载，Complex & operator+=(const Complex & rhs)～～～～

	// a++; //同理，自增自减也用成员函数方式（区分前置++，和，后之++）
	// ++a; //11：27？
	//后置++，定义的时候，返回的是对象，而且形参带个int，没实际意义，只是与前置++区分
	//前置++，返回的是引用
	{
		前置++，后置++ 的区别
		1、前置++返回的是引用
		2、后置++返回的是对象（会有临时对象的保存，return的时候还会调用复制构造函数，要不是有编译器的优化，会多出好几个步骤）
		---> 以后多用 ++i

		&(++a);//ok，返回的就是a本身
		&(a++);//error，返回的是一个临时变量，不能取地址
	}



-----> 发现一个问题，print函数针对负数的打印格式并不好，所以要改进一下
	{11：50？if-else逻辑懵了？？？}



-------------------------（tips：ctrl+n/p 选择提示的代码补全）


> 不能重载的运算符：
	ppt20页：长度运算符sizeof{是运算符，不是函数}....（带"点"的都不能重载）
	{运算符在编译时就可得到结果，而函数必须运行时}
> 内置类型的运算符不能重载（int等）

> 重载后，运算符的优先级不变
		&&和||丧失短路求值特性
> 不能乱编并重载一个不存在的运算符




